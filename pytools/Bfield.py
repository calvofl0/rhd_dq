#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
This is a module for the creation of general force-free X- and Y-periodic
magnetic fields.

AlfvÃ©n waves travel faster either when density is decreased or when magnetic
field is increased. Because of the Courant condition, the maximum time step
decreases if any of these two conditions is met.

Assuming an homogeneous magnetic field through a box, the time step is
most limited in the upper photosphere, where the density is low.

If we are interested in having important flux concentrations in the
photosphere without having heavy limitations from the Courant conditions,
we therefore need a very peculiar magnetic field, with lines concentrations
in the lower photosphere that bend and come back down, never reaching the
upper choromosphere.

In order to provide a smooth run, and avoid numerical instabilities, beside
requiring divB = 0, we also require the magnetic field to be "force free".
This means that the induced current does not contribute to the Lorentz
force. This condition can be rewritten as

	rot B = alpha B,

with alpha being a scalar field satisfying

	B * nabla alpha = 0.

A (reduced) family of solutions can be found setting alpha=0. In this case
the magnetic field is potential and ca be written B = nabla phi, for some
scalar function phi, and leading to the Laplace equation:

	nabla^2 phi = 0.

A general solution to this equation with periodic boundary conditions on
X and Y and asymptoting to some constant at infinity on the Z axis is:

	phi(x, y, z) = -A[0,0]z - Sum_{k_i,k_j} A[i,j]/sqrt(k_i^2+k_j^2) *
			sqrt(k_i^2+k_j^2)^(-1) * cos(k_i*x+k_j*y+d[i,j]) *
			exp(-sqrt(k_i^2+k_j^2)*(z-vshift[i,j]))

This solution is used to compute the magnetic field, with the free
parameters A, d and vshift given by matrices, whose shape determines
the number of terms in the sum. Note that the term k_i=k_j=0 is excluded
from the sum and d[0,0] and vshift[0,0] do not contribute at all.

The fields are computed in two different flavours: Bc fields are cell
centred fields whereas Bb fields are in fact average flux per unit area
at centres of cell boundaries.

Some specific fields are generated by:

	- sample2DField (A = [[10.], [100.]])
	- sample3DField (A = [[10., 100.], [100., 0.]])
	- final3DField (A = [[10., 246.4], [246.4, 0.]])

The two first functions generate fields on a 15Mm x 15Mm x 15Mm box
descending down to 5Mm below tau=1. The last function generates a field on
a 9.6Mm x 9.6Mm x 2.8Mm descending down to 1.24Mm below tau=1.

All three functions produce Bb fields. To obtain Bc fields as a linear
interpolation of Bb fields, the parametre centre=True can be passed.

For visualization, the functions

	- streamLines
	- plotStreamlines
	- plotFlux

can be used. The first function returns streamlines that can be passed
directly to plotStreamlines. The arguments to streamLines are *F and N, with
F=(xb1, xb2, xb3, Bb1, Bb2, Bb3) and N the number of desired streamlines.

plotFlux will plot the average unsigned field at some given depth vs depth.
It also take *F as argument.

'''

has_mpltools = True
has_yt = True
import numpy as np
try:
	import matplotlib.pyplot as plt
	from mpl_toolkits.mplot3d import Axes3D
except ImportError:
	has_mpltools = False

try:
	import yt
	from yt.visualization.api import Streamlines
except ImportError:
	has_yt = False

def meshgrid(x1, x2, x3=None):
	'''
	2D/3D "meshgrid", returns X, Y(, Z) so that
		* X_ijk = x1[i]
		* Y_ijk = x2[j]
		* Z_ijk = x3[k]
	'''
	if type(x3) != type(None):
		NX, NY, NZ = np.size(x1), np.size(x2), np.size(x3)
		X = np.repeat(np.array([np.repeat([x1],NY,axis=0)]),NZ,axis=0).T
		Y = np.repeat(np.array([np.repeat([x2],NZ,axis=0).T]),NX,axis=0)
		Z = np.repeat(np.array([np.repeat([x3],NY,axis=0)]),NX,axis=0)
		return X,Y,Z
	else:
		X, Y = np.meshgrid(x1,x2)
		return X.T, Y.T

def meshcellcentres(xb1, xb2, xb3):
	'''
	3D "meshgrid", returns X, Y, Z so that
		* X is the x-coordinate of centres of boundary cells
		  perpendicular to x
		* Y is the y-coordinate of centres of boundary cells
		  perpendicular to y
		* Z is the z-coordinate of centres of boundary cells
		  perpendicular to z
	'''
	NX, NY, NZ = np.size(xb1)-1, np.size(xb2)-1, np.size(xb3)-1
	X = np.repeat(np.array([np.repeat([xb1],NY,axis=0)]),NZ,axis=0).T
	Y = np.repeat(np.array([np.repeat([xb2],NZ,axis=0).T]),NX,axis=0)
	Z = np.repeat(np.array([np.repeat([xb3],NY,axis=0)]),NX,axis=0)
	return X,Y,Z

def BcField(Bmat, x, y, z, T=None, phase=None, vshift=None):
	'''
	Returns cell-centred force-free magnetic field
	'''
	s = np.shape(Bmat)
	X, Y, Z = meshgrid(x, y, z)
	Bx, By, Bz = 0., 0., 0.
	if T == None:
		Tx = x[-1]-x[0]
		Ty = y[-1]-y[0]
	else:
		if np.isscalar(T)==True:
			Tx = T
			Ty = T
		else: Tx, Ty = T
	if phase == None: phase = np.zeros_like(Bmat)
	else:
		phase = 2.*np.pi*phase*np.ones_like(Bmat)
		phase[0,0] = 0.
	if vshift == None: vshift = np.zeros_like(Bmat)
	else: vshift = vshift*np.ones_like(Bmat)
	for i in range(s[0]):
		for j in range(s[1]):
			if Bmat[i,j] == 0.: continue
			kx = 2.*np.pi*i/float(Tx)
			ky = 2.*np.pi*j/float(Ty)
			kz = np.sqrt(kx**2+ky**2)
			sq = np.sqrt(i**2+j**2)
			if sq>0.:
				lx = kx/kz
				ly = ky/kz
			else:
				lx = 0.
				ly = 0.
				Bz += Bmat[i,j] #*np.cos(phase[i,j])
				continue
			Bx += lx*Bmat[i,j]*np.sin(kx*X+ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))
			By += ly*Bmat[i,j]*np.sin(kx*X+ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))
			Bz += Bmat[i,j]*np.cos(kx*X+ky+Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))
	return Bx, By, Bz

def cellAreas(xb, yb, zb):
	'''
	Returns Ax, Ay, Az arrays, the cells boundary areas of boundaries
	perpendicular to x, y and z respectively
	'''
	X, Y, Z = meshgrid(xb, yb, zb)
	Ax = (Y[:,1:,:-1]-Y[:,:-1,:-1])*(Z[:,:-1,1:]-Z[:,:-1,:-1])
	Ay = (X[1:,:,:-1]-X[:-1,:,:-1])*(Z[:-1,:,1:]-Z[:-1,:,:-1])
	Az = (X[1:,:-1,:]-X[:-1,:-1,:])*(Y[:-1,1:,:]-Y[:-1,:-1,:])
	return Ax, Ay, Az

def cellVolumes(xb, yb, zb):
	'''
	Returns the volume of cells
	'''
	X, Y, Z = meshgrid(xb, yb, zb)
	return (X[1:,:-1,:-1]-X[:-1,:-1,:-1])*(Y[:-1,1:,:-1]-Y[:-1,:-1,:-1])*(Z[:-1,:-1,1:]-Z[:-1,:-1,:-1])

def BbField(Bmat, xb, yb, zb, T=None, phase=None, vshift=None):
	'''
	Returns Bb1, Bb2, Bb3, the average flux per unit area through
	each cell boundary
	'''
	s = np.shape(Bmat)
	X, Y, Z = meshgrid(xb, yb, zb)
	Ax, Ay, Az = cellAreas(xb, yb, zb)
	Bx, By, Bz = 0., 0., 0.
	if T == None:
		Tx = xb[-1]-xb[0]
		Ty = yb[-1]-yb[0]
	else:
		if np.isscalar(T)==True:
			Tx = T
			Ty = T
		else: Tx, Ty = T
	if phase == None: phase = np.zeros_like(Bmat)
	else:
		phase = 2.*np.pi*phase*np.ones_like(Bmat)
		phase[0,0] = 0.
	if vshift == None: vshift = np.zeros_like(Bmat)
	for i in range(s[0]):
		for j in range(s[1]):
			if Bmat[i,j] == 0.: continue
			kx = 2.*np.pi*i/float(Tx)
			ky = 2.*np.pi*j/float(Ty)
			kz = np.sqrt(kx**2+ky**2)
			sq = np.sqrt(i**2+j**2)
			if sq>0.:
				lx = kx/kz
				ly = ky/kz
			else:
				Bz += X*Y*Bmat[i,j] #*np.cos(phase[i,j])
				continue
			if ky != 0.:
				Bx += lx*Bmat[i,j]*np.cos(kx*X+ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/(ky*kz)
			elif kz != 0.:
				Bx -= lx*Y*Bmat[i,j]*np.sin(kx*X+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/kz
			if kx != 0.:
				By += ly*Bmat[i,j]*np.cos(kx*X+ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/(kx*kz)
			elif kz != 0.:
				By -= ly*X*Bmat[i,j]*np.sin(ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/kz
			if kx != 0. and ky != 0.:
				Bz -= Bmat[i,j]*np.cos(kx*X+ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/(kx*ky)
			elif kx != 0.:
				Bz += Y*Bmat[i,j]*np.sin(kx*X+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/kx
			elif ky != 0.:
				Bz += X*Bmat[i,j]*np.sin(ky*Y+phase[i,j])*np.exp(-kz*(Z-vshift[i,j]))/ky
	Bbx = (Bx[:,1:,1:]+Bx[:,:-1,:-1]-Bx[:,1:,:-1]-Bx[:,:-1,1:])/Ax
	Bby = (By[1:,:,1:]+By[:-1,:,:-1]-By[1:,:,:-1]-By[:-1,:,1:])/Ay
	Bbz = (Bz[1:,1:,:]+Bz[:-1,:-1,:]-Bz[1:,:-1,:]-Bz[:-1,1:,:])/Az
	return Bbx, Bby, Bbz

def Bcentre(Bb1,Bb2,Bb3):
	'''
	Converts a cell boundary centred magnetic field into a cell centred
	magnetic field, by linear interpolation
	'''
	Bc1 = .5*(Bb1[1:,:,:]+Bb1[:-1,:,:])
	Bc2 = .5*(Bb2[:,1:,:]+Bb2[:,:-1,:])
	Bc3 = .5*(Bb3[:,:,1:]+Bb3[:,:,:-1])
	return Bc1, Bc2, Bc3

def div(xb1, xb2, xb3, Bb1, Bb2, Bb3, flux=False):
	'''
	Computes divergence of a cell boundary centred magnetic field.
	
	The divergence can be zero only if the magnetic field is an average
	flux per unit area through the cells.
	'''
	if flux:
		F1 = Bb1[1:,:,:]-Bb1[:-1,:,:]
		F2 = Bb2[:,1:,:]-Bb2[:,:-1,:]
		F3 = Bb3[:,:,1:]-Bb3[:,:,:-1]
	else:
		Ax, Ay, Az = cellAreas(xb1, xb2, xb3)
		F1 = Bb1[1:,:,:]*Ax[1:,:,:]-Bb1[:-1,:,:]*Ax[:-1,:,:]
		F2 = Bb2[:,1:,:]*Ay[:,1:,:]-Bb2[:,:-1,:]*Ay[:,:-1,:]
		F3 = Bb3[:,:,1:]*Az[:,:,1:]-Bb3[:,:,:-1]*Az[:,:,:-1]
	return (F1+F2+F3)/cellVolumes(xb1, xb2, xb3)

def fluxProfile(xb1, xb2, xb3, Bb1, Bb2, Bb3, absolute=True):
	'''
	Returns the mean vertical magnetic field layer by layer
	(and not flux, has the name might suggest)
	'''
	#Ax, Ay, Az = cellAreas(xb1, xb2, xb3)
	#N = (np.size(xb1)-1.)*(np.size(xb2)-1.)
	if absolute:
		return np.apply_over_axes(np.mean,np.abs(Bb3),(0,1)).flatten()
	else:
		return np.sqrt(np.apply_over_axes(np.mean,(Bb3)**2,(0,1)).flatten())

def streamSeedsUniform(xc1, xc2, xc3, N):
	'''
	Returns seeds to compute streamlines distributed uniformly in the
	top and bottom of the computational box
	'''
	eps = 1.e-10
	xc1, xc2, xc3 = np.copy(xc1), np.copy(xc2), np.copy(xc3)
	d1, d2, d3 = xc1[-1]-xc1[0], xc2[-1]-xc2[0], xc3[-1]-xc3[0]
	xc1[0] += eps*d1
	xc1[-1] -= eps*d1
	xc2[0] += eps*d2
	xc2[-1] -= eps*d2
	xc3[0] += eps*d3
	xc3[-1] -= eps*d3
	s1,s2 = np.size(xc1),np.size(xc2)
	r = float(s2)/float(s1)
	S = s1*s2
	n2 = int(np.floor(np.sqrt(N/(2.*r))))
	n1 = int(np.floor(float(N)/float(2.*n2)))
	if n1%2 == 1 and s1%2 == 0: n1 -= 1
	if n2%2 == 1 and s2%2 == 0: n2 -= 1
	d1 = int(np.floor(s1/(n1-1.)))
	d2 = int(np.floor(s2/(n2-1.)))
	r1 = range(s1)[:d1*int(np.ceil(n1/2.)):d1]+range(s1)[s1-1-d1*int(np.floor(n1/2.)-1.)::d1]
	r2 = range(s2)[:d2*int(np.ceil(n2/2.)):d2]+range(s2)[s2-1-d2*int(np.floor(n2/2.)-1.)::d2]
	#print(str(r1))
	#print(str(r2))
	X, Y = meshgrid(xc1[r1], xc2[r2])
	bottom = np.array([[X.flatten()[i], Y.flatten()[i], xc3[0]] for i in range(int(np.size(X)))])
	top = np.array([[X.flatten()[i], Y.flatten()[i], xc3[-1]] for i in range(int(np.size(X)))])
	return bottom, top

def streamSeeds(xc1, xc2, xc3, Bc3, N):
	'''
	Returns seeds to compute streamlines. The seeds are cleverly
	distributed: uniformly in the top boundary, and uniformly on the
	region that contains only positive vertical field in the bottom
	boundary.
	'''
	eps = 1.e-10
	d1, d2, d3 = xc1[-1]-xc1[0], xc2[-1]-xc2[0], xc3[-1]-xc3[0]
	s1,s2 = np.size(xc1),np.size(xc2)
	S = s1*s2
	#X, Y = meshgrid(range(s1), range(s2))
	allSeeds = np.where(Bc3[1:int(s1/2),1:int(s2/2),0]>0.)
	seeds4 = (allSeeds[0][::int(S/(4*N))], allSeeds[1][::int(S/(4*N))])
	bottom = []
	for i in range(len(seeds4[0])):
		bottom.append([xc1[1+seeds4[0][i]], xc2[1+seeds4[1][i]], xc3[0]+eps*d3])
		bottom.append([xc1[s1-2-seeds4[0][i]], xc2[1+seeds4[1][i]], xc3[0]+eps*d3])
		bottom.append([xc1[1+seeds4[0][i]], xc2[s2-2-seeds4[1][i]], xc3[0]+eps*d3])
		bottom.append([xc1[s1-2-seeds4[0][i]], xc2[s2-2-seeds4[1][i]], xc3[0]+eps*d3])
	bottom = np.array(bottom)
	xc1, xc2, xc3 = np.copy(xc1), np.copy(xc2), np.copy(xc3)
	xc1[0] += eps*d1
	xc1[-1] -= eps*d1
	xc2[0] += eps*d2
	xc2[-1] -= eps*d2
	xc3[0] += eps*d3
	xc3[-1] -= eps*d3
	s1,s2 = np.size(xc1),np.size(xc2)
	r = float(s2)/float(s1)
	S = s1*s2
	n2 = int(np.floor(np.sqrt(N/(2.*r))))
	n1 = int(np.floor(float(N)/float(2.*n2)))
	if n1%2 == 1 and s1%2 == 0: n1 -= 1
	if n2%2 == 1 and s2%2 == 0: n2 -= 1
	d1 = int(np.floor(s1/(n1-1.)))
	d2 = int(np.floor(s2/(n2-1.)))
	r1 = range(s1)[:d1*int(np.ceil(n1/2.)):d1]+range(s1)[s1-1-d1*int(np.floor(n1/2.)-1.)::d1]
	r2 = range(s2)[:d2*int(np.ceil(n2/2.)):d2]+range(s2)[s2-1-d2*int(np.floor(n2/2.)-1.)::d2]
	X, Y = meshgrid(xc1[r1], xc2[r2])
	top = np.array([[X.flatten()[i], Y.flatten()[i], xc3[-1]] for i in range(int(np.size(X)))])
	return bottom, top

if has_yt:
	def makeYtDS(xc1, xc2, xc3, Bc1, Bc2, Bc3):
		'''
		Makes a dataset that can further be used with the yt module
		'''
		data = dict(B_x=(Bc1, 'G'), B_y=(Bc2, 'G'), B_z=(Bc3, 'G'))
		bbox = np.array([[xc1[0], xc1[-1]], [xc2[0], xc2[-1]], [xc3[0], xc3[-1]]])
		return yt.load_uniform_grid(data, Bc1.shape, length_unit='cm', bbox=bbox)

	def streamLines(xc1, xc2, xc3, Bc1, Bc2, Bc3, N):
		'''
		Computes streamlines. Automatically calls the streamSeeds
		function.
		'''
		#bottom, top = streamSeeds(xc1, xc2, xc3, N)
		bottom, top = streamSeeds(xc1, xc2, xc3, Bc3, N)
		#top = []
		#print(bottom)
		#print(top)
		bottom = np.array(bottom)
		top = np.array(top)
		#print(bottom)
		#return
		#bottom = [[.5,.5,.5],[.5,8.4999,.5]]
		ds = makeYtDS(xc1, xc2, xc3, Bc1, Bc2, Bc3)
		streamlines = Streamlines(ds, bottom, 'B_x', 'B_y', 'B_z', direction=1.0, length=3.*(xc3[-1]-xc3[0]))
		streamlines.integrate_through_volume()
		bottomstreamlines = streamlines.streamlines
		if len(top)>0:
			streamlines = Streamlines(ds, top, 'B_x', 'B_y', 'B_z', direction=-1.0, length=3.*(xc3[-1]-xc3[0]))
			streamlines.integrate_through_volume()
			topstreamlines = streamlines.streamlines
		else: topstreamlines = []
		streamlines = []
		for stream in bottomstreamlines:
			stream = stream[np.all(stream != 0.0, axis=1)]
			streamlines.append(stream)
		for stream in topstreamlines:
			stream = stream[np.all(stream != 0.0, axis=1)]
			streamlines.append(stream)
		return np.array(streamlines)
		#return np.concatenate((bottomstreamlines, topstreamlines))

def sample2DField(centre=True):
	'''
	Generates the simplest non-trivial 2D force-free magnetic field
	'''
	Bmat = np.array([[10.], [100.]])
	x, y, z = (np.linspace(0.,15.e8,100), np.linspace(0.,15.e8,100), np.linspace(-5.e8,10.e8,100))
	Bb = BbField(Bmat, x, y, z, phase=.5)
	#Bc = Bcentre(*Bb)
	#return (.5*(x[1:]+x[:-1]), .5*(y[1:]+y[:-1]), .5*(z[1:]+z[:-1]))+Bc
	if centre:
		Bc = Bcentre(*Bb)
		return (.5*(x[1:]+x[:-1]), .5*(y[1:]+y[:-1]), .5*(z[1:]+z[:-1]))+Bc
	else: return (x, y, z)+Bb

def sample3DField(centre=True):
	'''
	Generates the simplest non-trivial 3D force-free magnetic field
	'''
	Bmat = np.array([[10., 100.], [100., 0.]])
	phase = np.array([[0., 2./3.],[2./3., 0.]])
	x, y, z = (np.linspace(0.,15.e8,100), np.linspace(0.,15.e8,100), np.linspace(-5.e8,10.e8,100))
	#x, y, z = (np.linspace(0.,9.6e8,96), np.linspace(0.,9.6e8,96), np.linspace(-1.24e8,0.96e8,100))
	Bb = BbField(Bmat, x, y, z, phase=.5)
	#Bc = Bcentre(*Bb)
	#return (.5*(x[1:]+x[:-1]), .5*(y[1:]+y[:-1]), .5*(z[1:]+z[:-1]))+Bc
	if centre:
		Bc = Bcentre(*Bb)
		return (.5*(x[1:]+x[:-1]), .5*(y[1:]+y[:-1]), .5*(z[1:]+z[:-1]))+Bc
	else: return (x, y, z)+Bb

def final3DField(centre=True):
	'''
	Same as sample3DField but with parameters adjusted to match our
	requirements (average 200G unsigned magnetic field at the bottom)
	'''
	Bmat = np.array([[10., 246.4], [246.4, 0.]])
	#phase = np.array([[0., 2./3.],[2./3., 0.]])
	x, y, z = (np.linspace(0.,9.6e8,97), np.linspace(0.,9.6e8,97), np.linspace(-1.24e8,1.56e8,29))
	Bb = BbField(Bmat, x, y, z, phase=.5)
	if centre:
		Bc = Bcentre(*Bb)
		return (.5*(x[1:]+x[:-1]), .5*(y[1:]+y[:-1]), .5*(z[1:]+z[:-1]))+Bc
	else: return (x, y, z)+Bb

if has_mpltools:
	def plotStreamlines(lines, elev=None, azim=None, xlim=None, ylim=None, zlim=None, save=None):
		'''
		Plots streamlines that have to be previously computed
		with streamLines and passed as argument.

		The box window and the camera position can be adjusted.
		'''
		fig = plt.figure()
		ax = Axes3D(fig)
		for stream in lines:
			ax.plot3D(stream[:,0],stream[:,1],stream[:,2],alpha=.3)
		if xlim != None: ax.set_xlim(xlim[0], xlim[1])
		if ylim != None: ax.set_ylim(ylim[0], ylim[1])
		if zlim != None: ax.set_zlim(zlim[0], zlim[1])
		if elev != None and azim != None: ax.view_init(elev=elev, azim=azim)
		elif elev != None: ax.view_init(elev=elev)
		elif azim != None: ax.view_init(azim=azim)
		if save == None: plt.show()
		else:
			plt.savefig(save)
			plt.close()

	def plotFlux(xb1, xb2, xb3, Bb1, Bb2, Bb3, tau0=None):
		'''
		In spite of its name, this functions plots average vertical
		magnetic field (and not flux) in a given layer vs height.

		It calls fluxProfile to compute it.
		'''
		f = fluxProfile(xb1, xb2, xb3, Bb1, Bb2, Bb3)
		xb3 = np.copy(xb3)/1.e5
		fig = plt.figure()
		ax = fig.add_subplot(111)
		line, = ax.plot(xb3, f)
		M = np.argmax(f)
		m = np.argmin(f)
		dx = .1*(xb3[-1]-xb3[0])
		dy = .1*(f[-1]-f[0])
		ax.set_xlabel('Height [km]')
		ax.set_ylabel('Average unsigned magnetic field (vertical component) [G]')
		ax.annotate('Max. B field: '+str(int(round(f[M])))+' [G]', xy=(xb3[M]+.1*dx, f[M]+.1*dy), xytext=(xb3[M]+dx, f[M]+dy), arrowprops=dict(arrowstyle='->'))
		ax.annotate('Min. B field: '+str(int(round(f[m])))+' [G]', xy=(xb3[m]-.1*dx, f[m]-.1*dy), xytext=(xb3[m]-1.7*dx, f[m]-dy), arrowprops=dict(arrowstyle='->'))
		if tau0 != None:
			loc = np.where(np.logical_and(xb3[:-1]<=tau0,tau0<xb3[1:]))
			if len(loc) > 0: z1, z2 = loc[0], loc[0]+1
			else: z1, z2 = loc[-2], loc[-1]
			f0 = f[z1] + (f[z2]-f[z1])/(xb3[z2]-xb3[z1])*(tau0-xb3[z1]) 
			ax.annotate('B field at $\\tau=1$: '+str(int(round(f0)))+' [G]', xy=(tau0+.1*dx, f0), xytext=(tau0+dx, f0), arrowprops=dict(arrowstyle='->'))
		plt.show()

