#!/usr/bin/env python
# -*- coding: utf-8 -*-

from numpy import vectorize, pi, asarray, any, sqrt, where, arange, inf, exp, linspace, roll, floor, real, shape, zeros, zeros_like, ones, ones_like, ceil, log, exp, prod, sin, cos, meshgrid, arctan, mean, isscalar
from numpy import max as amax
from numpy import min as amin
from numpy import round as around
from numpy import abs as aabs
from numpy import sum as asum
from numpy.fft import fft2, ifft2, fftshift, ifftshift, fftn, ifftn
#from mpmath import j1 as j1_scalar
from scipy.special import j1
from matika import coordCyl
from pybold import kB, hbar, c
from scipy.signal import fftconvolve as convolve
from warnings import warn

#j1 = vectorize(j1_scalar)
#j1 = lambda x: jv(1, x)

visible_light = linspace(380.e-7, 750.e-7, 10)

def planck(wl, T):
	return 4.*pi*hbar*c**2/wl**5*(exp(2.*pi*hbar*c/(wl*kB*T))-1.)**(-1)

def airyPSF(x, y, a, r, wl, T=None, resize=False):
	'''
Returns the PSF of a perfect lens with circular aperture
If resize is set to True, the size of the output array is the minimal size
allowing exact convolution (no boundary effects) with an image. So with

   len(x) = Nx, len(y) = Ny

we would obtain shape(psf) = (2*Nx - 1, 2*Ny - 1)

Parameters
==========
x, y : array_like
       Coordinate array of the image

a :    scalar (float)
       Aperture

r :    scalar (float)
       Distance from the optics to the object

wl :   scalar (float) / array_like
       Wavelength(s)

T :    scalar (float), required when wl is array_like
       Black body temperature
	'''
	if not hasattr(wl, '__len__'):
		wl = [wl]
		multiple_wl = False
	else:
		multiple_wl = True
		if T == None:
			raise ValueError('Black body temperature must be provided')
	psf_bol = []
	N = 0.
	x  = asarray(x)
	y  = asarray(y)
	Nx = len(x)
	Ny = len(y)
	dx = x[1] - x[0]
	dy = y[1] - y[0]
	if any(x[1:] - x[:-1] != dx) or any(y[1:] - y[:-1] != dy):
		warn("Coordinates must be equidistant")
	if resize:
		X = arange(-(Nx-1)*dx,Nx*dx+dx/2.,dx)
		Y = arange(-(Ny-1)*dy,Ny*dy+dy/2.,dy)
	else:
		X = roll(arange(-floor(Nx/2.)*dx,Nx/2.*dx,dx),-int(floor(Nx/2.)))
		Y = roll(arange(-floor(Ny/2.)*dy,Ny/2.*dy,dy),-int(floor(Ny/2.)))
	R, theta, z = coordCyl(X,Y,[0],[X[0],Y[0],0],[0,0,1])
	R = sqrt(R[0][:,:,0]**2 + R[1][:,:,0]**2)
	for l in wl:
		k  = 2.*pi/l
		z = .5*k*a*(R/r)/sqrt(1.+(R/r)**2)
		z[where(R==0.)] = 1.
		print('\tEvaluation of the Bessel function (wl = '+str(l)+')...')
		psf_val = (2.*asarray(j1(z),dtype=float)/z)**2
		psf_val[where(R==0.)] = 1.
		if multiple_wl:
			pl = planck(l, T)
		else:
			pl = 1.
		psf_bol += [pl*psf_val]
		N += pl
	psf_airy = sum(psf_bol)/N
	return psf_airy/asum(psf_airy)

def spiderPupil(a, d, n, w, r, tangent=False):
	'''
Returns the pupil of a telescope taking into account the spider and a central
obscuration.

Parameters
==========

a : scalar (float)
    Telescope aperture

d : scalar (float)
    Diameter of the central obscuration

n : scalar (integer)
    Number of legs in the spider

w : scalar (float)
    Width of the spider's legs

r : scalar (integer)
    Radius of the returned array (it's shape will be (2*r+1, 2*r+1))
	'''

	rco = float(d)/float(a) * r # Radius of the central obscuration in pixs
	rsl = float(w)/float(a) * r # Half-width of the spider legs in pixs

	pupil = zeros((2*r+1, 2*r+1))

	if w == 0.:
		n=0
	for i in range(2*r+1):
		for j in range(2*r+1):
			if (i-r)**2 + (j-r)**2 <= r**2:
				pupil[i,j] = 1.
			if (i-r)**2 + (j-r)**2 <= rco**2:
				pupil[i,j] = 0.
			for k in range(n):
				if tangent:
					cX = r-(rco-rsl)*sin(2.*pi*float(k)/float(n))
					cY = r+(rco-rsl)*cos(2.*pi*float(k)/float(n))
				else:
					cX = r
					cY = r
				c  = cos(2.*pi*float(k)/float(n))
				s  = sin(2.*pi*float(k)/float(n))
				sp = c*(i-cX) + s*(j-cY)
				if (i-cX)**2 + (j-cY)**2 - sp**2 <= rsl**2 and sp >= 0.:
					pupil[i,j] = 0.

	return pupil

def generalPSF(mask, x, y, a, r, wl, T=None, gamma=None, sigma=None):
	'''
Returns the diffraction-limited PSF generated by a given pupil, convolved with
a Voigt profile specified by the parameters gamma and sigma.

Parameters
==========

mask :  array_like (2D)
        The actual pupil of the telescope

x, y :  array_like
        Coordinate array of the image

a :     scalar (float)
        Aperture

r :     scalar (float)
        Distance from the optics to the object

wl :    scalar (float) / array_like
        Wavelength(s)

T :     scalar (float), required when wl is array_like
        Black body temperature

gamma : scalar (float)
        Parameter of the Lorentz profile (in arcsec)

sigma : scalar (float)
        Parameter of the Gaussian profile (in arcsec)

Note:   The convolution of the Lorentz and the Gaussian profiles lead to the
=====   Voigt profile
	'''
	if not hasattr(wl, '__len__'):
		wl = [wl]
		multiple_wl = False
	else:
		multiple_wl = True
		if T == None:
			raise ValueError('Black body temperature must be provided')
	psf_bol = []
	N = 0.
	x  = asarray(x)
	y  = asarray(y)
	Nx = len(x)
	Ny = len(y)
	dx = x[1] - x[0]
	dy = y[1] - y[0]
	if any(x[1:] - x[:-1] != dx) or any(y[1:] - y[:-1] != dy):
		warn("Coordinates must be equidistant")
	if not (gamma is None and sigma is None):
		X = roll(arange(-floor(Nx/2.)*dx,Nx/2.*dx,dx),-int(floor(Nx/2.)))
		Y = roll(arange(-floor(Ny/2.)*dy,Ny/2.*dy,dy),-int(floor(Ny/2.)))
		R, theta, z = coordCyl(X,Y,[0],[X[0],Y[0],0],[0,0,1])
		R = sqrt(R[0][:,:,0]**2 + R[1][:,:,0]**2)
	nonIdeal = ones((Nx,Ny), dtype=complex)
	if gamma == 0.:
		gamma = None
	if sigma == 0.:
		sigma = None
	if not gamma is None:
		gamma = r*arctan(gamma*2.*pi/(360.*3600.))
		nonIdeal *= fft2(.5*gamma/(pi*(R**2+.25*gamma**2)))
	if not sigma is None:
		sigma = r*arctan(sigma*2.*pi/(360.*3600.))
		nonIdeal *= fft2(exp(-R**2/(2.*sigma**2))/(sqrt(2.*pi)*sigma))
	for l in wl:
		Lx = l/(Nx*sin(dx/r))
		Ly = l/(Ny*sin(dy/r))
		s  = (1+2*int(floor(.5*a/Lx)), 1+2*int(floor(.5*a/Ly)))
		mask_resampled = resample(mask, s)
		mask_padded    = real(zeroPadding(mask_resampled, (Nx, Ny)))
		#mask_shifted   = (-1)**sum(meshgrid(arange(Nx), arange(Ny)))*mask_padded
		psf_val = aabs(fft2(mask_padded))**2
		#psf_val = psf_val/psf_val[int(floor(Nx/2.)),int(floor(Ny/2.))]
		psf_val = psf_val/asum(psf_val)
		if multiple_wl:
			pl = planck(l, T)
		else:
			pl = 1.
		psf_bol += [pl*psf_val]
		N += pl
	if gamma is None and sigma is None:
		return sum(psf_bol)/N
	else:
		nonIdeal /= nonIdeal[0,0]
		psf_nonIdeal = real(ifft2(fft2(sum(psf_bol)/N)*nonIdeal))
		#return aabs(ifft2(nonIdeal))
		#print(mean(psf_nonIdeal))
		return psf_nonIdeal

def degrade(image, x=None, y=None, a=None, r=None, psf=None, wl=visible_light, T=None, cyclic=True):
	'''
Degrades an image with the PSF of a perfect lens with circular aperture or
with a provided PSF.

Parameters
==========
image: array_like (2D)
       Image to degrade

x, y : array_like
       Coordinate array of the image

a :    scalar (float) / array_like
       Aperture / PSF

r :    scalar (float)
       Distance from the optics to the object

wl :   scalar (float) / array_like
       Wavelength(s), visible bolometric spectrum assumed
       if not provided

T :    scalar (float), required when wl is array_like
       Black body temperature, solar temperature assumed
       when wl=visible_light and T not provided

	'''
	if wl is visible_light and T is None:
		T = 5777.
	if psf is None:
		print("Calculating PSF...")
		PSF = airyPSF(asarray(x), asarray(y), a, r, wl, T, resize=not cyclic)
		print("Convolving...")
	else:
		PSF = psf
	if cyclic:
		return real(ifft2(fft2(PSF)*fft2(image)))
	else:
		return convolve(PSF, image, mode='valid')

def zeroPadding(arr, s=None, val=0.):
	'''
Pads and array with zeros or with an other specified value, adding values
to the edges of the array.

If the new shape is smaller than the old one, cropping is performed instead
of padding.

Parameters
==========
arr :  array to pad

s :    new shape (optional, returns arr if s is not provided)

val :  value for padding (optional, defaults to zero)
	'''
	if s is None: return arr
	s0 = shape(arr)
	z = val*ones(s, dtype=complex)
	idx0 = amax(asarray([ceil((asarray(s0)-asarray(s))/2.), zeros_like(s)], dtype=int), axis=0)
	idx1 = amax(asarray([ceil((asarray(s)-asarray(s0))/2.), zeros_like(s)], dtype=int), axis=0)
	idx0f = idx0 + amin(asarray([s, s0], dtype=int), axis=0)
	idx1f = idx1 + amin(asarray([s, s0], dtype=int), axis=0)
	s0 = [slice(idx0[i], idx0f[i]) for i in range(len(s))]
	s1 = [slice(idx1[i], idx1f[i]) for i in range(len(s))]
	z[s1] = arr[s0]
	return z

def centralZeroPadding(arr, s=None, val=0.):
	'''
Pads and array with zeros or with an other specified value, adding values
to the middle of the array.

If the new shape is smaller than the old one, cropping is performed instead
of padding.

Parameters
==========
arr :  array to pad

s :    new shape (optional, returns arr if s is not provided)

val :  value for padding (optional, defaults to zero)
	'''
	if s is None: return arr
	return ifftshift(zeroPadding(fftshift(arr), s, val))

def resample(arr, s=None):
	'''
Resamples an array

Parameters
==========
arr :  array to resample

s :    new shape (optional, returns arr if s is not provided)
	'''
	s0 = shape(arr)
	if s is None: return arr
	if s == s0: return arr
	return float(prod(s))/float(prod(s0))*real(ifftn(ifftshift(zeroPadding(fftshift(fftn(arr)), s))))

def resamplePSF(psf, csIn, csOut=None, s=None, accuracy=1.e-3, central=False):
	'''
Resamples a PSF. Allows to both change the physical cell spacing and the
number of grid cells (the shape).

The algorithm first resamples the PSF to an array of shape determined by
given accuracy (its cell spacing is given by 1./accuracy), then
padding/cropping is performed, and finally the array is resampled to the
desired shape.

Parameters
==========
psf :  the old PSF

csIn : cell spacing in the old PSF

csOut: cell spacing in the new PSF (optional, uses csIn if not provided)

s :    new shape (optional, preserves shape if not provided)

accuracy: optional, defaults to 1.e-3 (suitable for initial PSF smaller
                    than 1000 x 1000)
	'''
	if central: pad = centralZeroPadding
	else: pad = zeroPadding
	if csOut == None: csOut = csIn
	s0 = shape(psf)
	if s == None: s = s0

	#f = asarray(csOut)*asarray(s)/(asarray(csIn)*asarray(s0))
	#sRes = asarray(around(asarray(s)/f), dtype=int)
	#print(sRes)
	#psfRes = resample(log(psf), sRes)
	#return psfRes
	#return exp(real(pad(psfRes, s, val=float('-inf'))))
	#return exp(resample(psfCut, s))


	sCut = int(ceil(1./accuracy)) * ones_like(s0)
	sCutPad = asarray(2.*around(.5*asarray(csOut)*asarray(s)/(accuracy*asarray(csIn)*asarray(s0))), dtype=int)
	psfResample = resample(log(psf), sCut)
	psfCut = pad(psfResample, sCutPad, val=amin(psfResample))
	#return real(psfCut)
	return exp(resample(real(psfCut), s))
